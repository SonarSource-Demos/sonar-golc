package main

import (
	"os"
	"testing"

	"github.com/SonarSource-Demos/sonar-golc/pkg/utils"
)

// TestRepositorySummaryIntegration tests the integration of repository summary generation in golc.go
func TestRepositorySummaryIntegration(t *testing.T) {
	// Create temporary directory for test files
	tempDir, err := os.MkdirTemp("", "test_golc_integration_*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Change to temp directory
	originalWd, _ := os.Getwd()
	defer os.Chdir(originalWd)
	os.Chdir(tempDir)

	// Create necessary directory structure that golc.go expects
	dirs := []string{
		"Logs",
		"Results/config",
		"Results/byfile-report",
		"byfile-report/csv-report",
		"byfile-report/pdf-report",
	}
	for _, dir := range dirs {
		err = os.MkdirAll(dir, 0755)
		if err != nil {
			t.Fatalf("Failed to create dir %s: %v", dir, err)
		}
	}

	t.Run("Repository summary integration with no analysis files", func(t *testing.T) {
		// Test the specific lines added to golc.go (lines 1380-1383)
		// This simulates the call: utils.GenerateRepositorySummaryReports(DestinationResult)

		// This should skip gracefully when no analysis files exist
		err := utils.GenerateRepositorySummaryReports(tempDir)
		if err != nil {
			t.Errorf("GenerateRepositorySummaryReports() error = %v, want nil (should skip gracefully)", err)
		}
	})

	t.Run("Repository summary integration with analysis files", func(t *testing.T) {
		// Create analysis result file to simulate what golc.go would have created
		analysisData := `{
			"NumRepositories": 1,
			"ProjectBranches": [
				{
					"Org": "integration-org",
					"ProjectKey": "integration-project",
					"RepoSlug": "integration-repo",
					"MainBranch": "main",
					"SizeRepo": "1MB",
					"TotalCommits": 50
				}
			]
		}`

		err = os.WriteFile("Results/config/analysis_result_github.json", []byte(analysisData), 0644)
		if err != nil {
			t.Fatalf("Failed to create analysis file: %v", err)
		}

		// Create byfile report that would be generated by golc.go
		byfileData := `{
			"TotalLines": 500,
			"TotalBlankLines": 50,
			"TotalComments": 100,
			"TotalCodeLines": 350,
			"Results": []
		}`

		err = os.WriteFile("Results/byfile-report/Result_integration-org_integration-repo_main_byfile.json", []byte(byfileData), 0644)
		if err != nil {
			t.Fatalf("Failed to create byfile report: %v", err)
		}

		// Test the integration - this exercises the new code added to golc.go
		err = utils.GenerateRepositorySummaryReports(tempDir)
		if err != nil {
			t.Errorf("GenerateRepositorySummaryReports() error = %v, want nil", err)
		}

		// Verify that the reports were generated (this validates the integration works)
		expectedFiles := []string{
			"byfile-report/csv-report/repository_summary.csv",
			"byfile-report/repository_summary.json",
			"byfile-report/pdf-report/repository_summary.pdf",
		}

		for _, file := range expectedFiles {
			fullPath := tempDir + "/" + file
			if _, err := os.Stat(fullPath); os.IsNotExist(err) {
				t.Errorf("Expected report file was not created by integration: %s", file)
			}
		}
	})

	t.Run("Repository summary error handling integration", func(t *testing.T) {
		// Clean up previous files
		os.RemoveAll("Results")

		// Create only logs directory
		err = os.MkdirAll("Logs", 0755)
		if err != nil {
			t.Fatalf("Failed to create Logs dir: %v", err)
		}

		// Test error handling - this exercises the error logging added to golc.go
		// The specific lines: if err != nil { logger.Errorf("‚ùå Error creating repository summary reports: %v", err) }

		// This should handle the error gracefully and log it
		err = utils.GenerateRepositorySummaryReports(tempDir)
		// The function should not return an error (it logs and continues)
		if err != nil {
			t.Errorf("GenerateRepositorySummaryReports() error = %v, want nil (should handle errors gracefully)", err)
		}
	})
}

// TestGolcRepositorySummaryCall tests the specific new code added to golc.go
func TestGolcRepositorySummaryCall(t *testing.T) {
	// Create temporary directory
	tempDir, err := os.MkdirTemp("", "test_golc_call_*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Change to temp directory
	originalWd, _ := os.Getwd()
	defer os.Chdir(originalWd)
	os.Chdir(tempDir)

	// Create Logs directory for logger
	err = os.MkdirAll("Logs", 0755)
	if err != nil {
		t.Fatalf("Failed to create Logs dir: %v", err)
	}

	t.Run("Direct function call matches golc.go integration", func(t *testing.T) {
		// This tests the exact function call added to golc.go:
		// err = utils.GenerateRepositorySummaryReports(DestinationResult)

		destinationResult := tempDir
		err := utils.GenerateRepositorySummaryReports(destinationResult)

		// This should match the behavior in golc.go - no error returned, just logged
		if err != nil {
			t.Errorf("utils.GenerateRepositorySummaryReports() error = %v, want nil", err)
		}
	})

	t.Run("Function behavior with different directory structures", func(t *testing.T) {
		// Test how the function behaves with different directory setups
		// that might exist when golc.go calls it

		testCases := []struct {
			name      string
			setupDirs []string
			expectErr bool
		}{
			{
				name:      "Empty directory",
				setupDirs: []string{},
				expectErr: false, // Should skip gracefully
			},
			{
				name:      "Only Results directory",
				setupDirs: []string{"Results"},
				expectErr: false, // Should skip gracefully
			},
			{
				name:      "Results with config",
				setupDirs: []string{"Results", "Results/config"},
				expectErr: false, // Should skip gracefully (no analysis files)
			},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				// Clean up
				os.RemoveAll("Results")

				// Create test directories
				for _, dir := range tc.setupDirs {
					err = os.MkdirAll(dir, 0755)
					if err != nil {
						t.Fatalf("Failed to create dir %s: %v", dir, err)
					}
				}

				// Test the function call
				err := utils.GenerateRepositorySummaryReports(tempDir)

				if (err != nil) != tc.expectErr {
					t.Errorf("GenerateRepositorySummaryReports() error = %v, expectErr = %v", err, tc.expectErr)
				}
			})
		}
	})
}

// TestGolcMainFlowIntegration tests how the repository summary fits into the main golc flow
func TestGolcMainFlowIntegration(t *testing.T) {
	// Create temporary directory
	tempDir, err := os.MkdirTemp("", "test_golc_main_flow_*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Change to temp directory
	originalWd, _ := os.Getwd()
	defer os.Chdir(originalWd)
	os.Chdir(tempDir)

	// Create necessary directories
	dirs := []string{
		"Logs",
		"Results",
		"Results/config",
		"Results/byfile-report",
		"byfile-report/csv-report",
		"byfile-report/pdf-report",
	}
	for _, dir := range dirs {
		err = os.MkdirAll(dir, 0755)
		if err != nil {
			t.Fatalf("Failed to create dir %s: %v", dir, err)
		}
	}

	t.Run("Repository summary in main flow sequence", func(t *testing.T) {
		// Simulate the sequence in golc.go main function:
		// 1. Analysis is done (we simulate this)
		// 2. Global report is created (we simulate this)
		// 3. Repository summary reports are generated (this is what we're testing)

		// Step 1: Simulate analysis results
		analysisData := `{
			"NumRepositories": 2,
			"ProjectBranches": [
				{
					"Org": "flow-org",
					"RepoSlug": "repo1",
					"MainBranch": "main"
				},
				{
					"Org": "flow-org", 
					"RepoSlug": "repo2",
					"MainBranch": "develop"
				}
			]
		}`

		err = os.WriteFile("Results/config/analysis_result_github.json", []byte(analysisData), 0644)
		if err != nil {
			t.Fatalf("Failed to create analysis file: %v", err)
		}

		// Step 2: Simulate byfile reports
		byfileData1 := `{"TotalLines": 200, "TotalBlankLines": 20, "TotalComments": 40, "TotalCodeLines": 140}`
		err = os.WriteFile("Results/byfile-report/Result_flow-org_repo1_main_byfile.json", []byte(byfileData1), 0644)
		if err != nil {
			t.Fatalf("Failed to create byfile report 1: %v", err)
		}

		byfileData2 := `{"TotalLines": 150, "TotalBlankLines": 15, "TotalComments": 30, "TotalCodeLines": 105}`
		err = os.WriteFile("Results/byfile-report/Result_flow-org_repo2_develop_byfile.json", []byte(byfileData2), 0644)
		if err != nil {
			t.Fatalf("Failed to create byfile report 2: %v", err)
		}

		// Step 3: Test repository summary generation (the new code in golc.go)
		err = utils.GenerateRepositorySummaryReports(tempDir)
		if err != nil {
			t.Errorf("GenerateRepositorySummaryReports() in main flow error = %v, want nil", err)
		}

		// Verify all reports were generated
		reports := []string{
			"byfile-report/csv-report/repository_summary.csv",
			"byfile-report/repository_summary.json",
			"byfile-report/pdf-report/repository_summary.pdf",
		}

		for _, report := range reports {
			fullPath := tempDir + "/" + report
			if _, err := os.Stat(fullPath); os.IsNotExist(err) {
				t.Errorf("Main flow integration failed to create report: %s", report)
			}
		}
	})
}
